---
layout: post
title: Doctrine ORM Hydration Performance Optimization
category: PHP
tags: ["php", "doctrine", "orm", "hydration", "performance", "speed"]
year: 2015
month: 4
day: 10
published: true
summary: Squeezing performance out of the most expensive operation that Doctrine ORM is doing for you 
description: Hydration is the most expensive operation performed by Doctrine ORM: how do we prevent it from killing our applications?
tweet: 
---

<h2>What is hydration?</h2>

<p>
    Doctrine ORM, like most ORMs, is performing a process called <strong>Hydration</strong> when converting database
    results into objects.
</p>

<p>
    This process usually involves reading a record from a database result and then converting the column values
    into an object's properties.
</p>

<p>
    Here is a little pseudo-code snippet that shows what a mapper is actually doing under the hood:
</p>

~~~php
<?php
$results = [];

foreach ($resultSet->fetchRow() as $row) {
    $object = new $mappedClassName;

    foreach ($mappingInformation->reflectionFields() as $column => $reflectionField) {
        $reflectionField->setValue($object, $row[$column]);
    }

    $results[] = $object;
}

return $results;
~~~

<p>
    That's a very basic example, but this gives you an idea of what an ORM is doing for you.
</p>

<p>
    As you can see, this is an <code>O(N)</code> operation (assuming a constant number of reflection fields).
</p>

<p>
    There are multiple ways to speed up this particular process, but we can only remove constant overhead from
    it, and not actually reduce it to something more efficient.
</p>

<h2>When is hydration expensive?</h2>

<p>
    Hydration starts to become expensive with complex resultsets.
</p>

<p>
    Take, the following SQL query:
</p>

~~~sql
SELECT
    u.id       AS userId,
    u.username AS userUsername,
    s.id       AS socialAccountId,
    s.username AS socialAccountUsername,
    s.type     AS socialAccountType
FROM
    user u
LEFT JOIN
    socialAccount s
        ON s.userId = u.id
~~~

<p>
    Assuming that the relation from <code>user</code> to <code>socialAccount</code> is a <code>one-to-many</code>,
    this query retrieves all the social accounts for all the users in our application
</p>

<p>
    A resultset may be as follows:
</p>

<table>
    <thead>
        <tr>
            <td>userId</td>
            <td>userUsername</td>
            <td>socialAccountId</td>
            <td>socialAccountUsername</td>
            <td>socialAccountType</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>20</td>
            <td>ocramius</td>
            <td>Facebook</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>21</td>
            <td>@ocramius</td>
            <td>Twitter</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>22</td>
            <td>ocramiusaethril</td>
            <td>Last.fm</td>
        </tr>
        <tr>
            <td>2</td>
            <td>grandpa@example.com</td>
            <td><code>NULL</code></td>
            <td><code>NULL</code></td>
            <td><code>NULL</code></td>
        </tr>
        <tr>
            <td>3</td>
            <td>grandma@example.com</td>
            <td>85</td>
            <td>awesomegrandma9917</td>
            <td>Facebook</td>
        </tr>
    </tbody>
</table>

<p>
    As you can see, we are now joining 2 tables in the results, and the ORM has to perform more complicated operations:
</p>

<ol>
    <li>
        Hydrate
        <strong>1</strong> 
        <code>User</code> 
        object for
        <i>ocramius@gmail.com</i>
    </li>
    <li>
        Hydrate
        <strong>3</strong>
        <code>SocialAccount</code> 
        instances into 
        <code>User#$socialAccounts</code> 
        for 
        <i>ocramius@gmail.com</i>,
        while skipping re-hydrating
        <code>User</code>
        <i>ocramius@gmail.com</i>
    </li>
    <li>
        Hydrate
        <strong>1</strong>
        <code>User</code>
        object for
        <i>grandpa@example.com</i>
    </li>
    <li>
        Skip hydrating
        <code>User#$socialAccounts</code>
        for
        <i>grandpa@example.com</i>,
        as no social accounts are associated
    </li>
    <li>
        Hydrate
        <strong>1</strong>
        <code>User</code>
        object for
        <i>grandma@example.com</i>
    </li>
    <li>
        Hydrate
        <strong>1</strong>
        <code>SocialAccount</code>
        instance into
        <code>User#$socialAccounts</code>
        for
        <i>grandma@example.com</i>
    </li>
</ol>

<p>
    This operation is what is done by Doctrine ORM when you use the
    <abbr title="Doctrine Query Language">DQL</abbr>
    <a href="http://docs.doctrine-project.org/en/latest/reference/dql-doctrine-query-language.html#joins" target="_blank">
        Fetch Joins
    </a>
    feature.
</p>

<p>
    Fetch joins are a very efficient way to hydrate multiple records without resorting to multiple queries, but there
    are two performance issues with this approach (both not being covered by this article):
</p>

<ul>
    <li>
        Empty records require some useless looping inside the ORM internals (see <i>grandpa@example.com</i>'s
        social account). This is a quick operation, but we can't simply ignore those records upfront.
    </li>
    <li>
        If multiple duplicated records are being joined (happens a lot in <code>many-to-many</code> associations),
        then we want to de-duplicate records by keeping a temporary in-memory identifier map.
    </li>
</ul>

<p>
    Additionally, our operation starts to become more complicated, as it is now <code>O(n * m)</code>, with
    <code>n</code> and <code>m</code> being the records in the <code>user</code> and the <code>socialAccount</code>
    tables.
</p>

<p>
    What the ORM is actually doing here is <strong>normalizing</strong> data that was fetched in a de-normalized
    resultset, and that is going through your CPU and your memory.
</p>

<h2>Bringing hydration cost to an extreme</h2>

<p>
    The process of hydration becomes extremely expensive when more than <strong>2</strong> <code>LEFT JOIN</code>
    operations clauses are part of our queries:
</p>

~~~sql
SELECT
    u.id         AS userId,
    u.username   AS userUsername,
    s.id         AS socialAccountId,
    s.username   AS socialAccountUsername,
    s.type       AS socialAccountType,
    as.id        AS sessionId,
    as.expiresOn AS sessionExpiresOn,
FROM
    user u
LEFT JOIN
    socialAccount s
        ON s.userId = u.id
LEFT JOIN
    session as
        ON as.userId = u.id
~~~

<p>
    This kind of query produces a much larger resultset, and the results are duplicated by a lot:
</p>

<table>
    <thead>
        <tr>
            <td>userId</td>
            <td>userUsername</td>
            <td>socialAccountId</td>
            <td>socialAccountUsername</td>
            <td>socialAccountType</td>
            <td>sessionId</td>
            <td>sessionExpiresOn</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>20</td>
            <td>ocramius</td>
            <td>Facebook</td>
            <td>b1fc7171/ocramius-macbook</td>
            <td>2015-04-20 22:08:56</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>21</td>
            <td>@ocramius</td>
            <td>Twitter</td>
            <td>b1fc7171/ocramius-macbook</td>
            <td>2015-04-20 22:08:56</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>22</td>
            <td>ocramiusaethril</td>
            <td>Last.fm</td>
            <td>b1fc7171/ocramius-macbook</td>
            <td>2015-04-20 22:08:56</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>20</td>
            <td>ocramius</td>
            <td>Facebook</td>
            <td>hh678114/ocramius-android</td>
            <td>2015-04-20 22:08:56</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>21</td>
            <td>@ocramius</td>
            <td>Twitter</td>
            <td>hh678114/ocramius-android</td>
            <td>2015-04-20 22:08:56</td>
        </tr>
        <tr>
            <td>1</td>
            <td>ocramius@gmail.com</td>
            <td>22</td>
            <td>ocramiusaethril</td>
            <td>Last.fm</td>
            <td>hh678114/ocramius-android</td>
            <td>2015-04-20 22:08:56</td>
        </tr>
        <tr>
            <td>2</td>
            <td>grandpa@example.com</td>
            <td><code>NULL</code></td>
            <td><code>NULL</code></td>
            <td><code>NULL</code></td>
            <td><code>NULL</code></td>
            <td><code>NULL</code></td>
        </tr>
        <tr>
            <td>3</td>
            <td>grandma@example.com</td>
            <td>85</td>
            <td>awesomegrandma9917</td>
            <td>Facebook</td>
            <td>aaaa123/home-pc</td>
            <td>2015-04-15 10:05:31</td>
        </tr>
    </tbody>
</table>