---
layout: post
title: Dependency Injection slowness solved by Doctrine Proxies
category: Coding
tags: zend zendframework zf2 symfony doctrine dependency injection proxies
year: 2012
month: 11
day: 19
published: true
summary: An explanation of how Doctrine Proxies work to enhance Zend Framework 2 and Symfony 2 services
---

<div class="row">

    <h2>Dependency Injection Containers and Performance</h2>

    <p>
        <a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank">Dependency Injection Containers</a>
        are a vital tool for developers of complex and modular applications. Using a Dependency Injection Container in
        your application brings you great benefits, allowing you to program without the need of the well known evil
        <strong>static methods and properties</strong> to get access to i.e. your database connection or your logger
        service.
    </p>
    <p>
        By using a Dependency Injection Container you automatically gain some benefits:
    </p>
    <ul>
        <li>
            <strong>Absence of hardcoded dependencies</strong>: Your objects do not handle instantiation of their
            dependencies, so you have one less problem to handle.
        </li>
        <li>
            <strong>Better separation of concerns</strong>: Splitting problems across multiple objects becomes easier
            as the container helps you gluing them all together.
        </li>
        <li>
            <strong>Mocking is much easier</strong>: Since you compose your instances with other dependencies that solve
            small problems, mocking those objects becomes really easy, and so writing tests for your application.
        </li>
    </ul>
    <p>
        But there is one major pitfall: since your objects do not handle instantiation of their dependencies anymore
        you are now building huge object graphs, even if you're not using all of those objects. Take for example
        following code:
    </p>
<pre class="prettyprint linenums lang-prepro">class A {}

class B {}

class C {}

class D {
    public function __construct(A $a, B $b, C $c)
    {
        // ...
    }
}

class HelloWorld
{
    public function __construct(D $d)
    {
        // ...
    }

    public function sayHello()
    {
        return 'Hello World';
    }
}</pre>
    <p>
        The example is obviously nonsense, but this actually happens in your MVC controllers, where you may have 3 or 4
        actions and none of them using all of the dependencies of the controller itself.
    </p>
    <p>
        As you notice, to call <code>HelloWorld#sayHello()</code> we are required to instantiate 5 objects:
        <code>A, B, C, D, HelloWorld</code>. While this is very robust code that will hardly break if A, B, C and D
        are correctly unit-tested, we are obviously having performance issues.
        This becomes particularly noticeable when one of these objects needs to allocate a lot of resources or to
        perform costly operations such as opening a file or a socket to a remote machine.
    </p>
    <p>
        We can then assume that pure Dependency Injection is fantastic to achieve code stability, but introduces
        performance drawbacks, especially in PHP, where the object graph is rebuilt at each dispatched request.
    </p>

    <hr/>

    <h2>Service Location (to the rescue?)</h2>

    <p>
        This brings us to the usage of a <a href="http://martinfowler.com/articles/injection.html#UsingAServiceLocator"
        target="_blank">Service Locator</a>:
    </p>
<pre class="prettyprint linenums lang-prepro">class HelloWorld
{
    public function __construct(ServiceLocator $serviceLocator)
    {
        // ...
    }

    public function sayHello()
    {
        return 'Hello World';
    }

    public function doSomethingWithD()
    {
        if ( ! $this-&gt;d) {
            $this-&gt;d = $this-&gt;serviceLocator-&gt;get('D');
        }

        $this-&gt;d-&gt;doSomething();
    }
}</pre>
    <p>
        As you will have noticed, this solves the performance issue by allowing us to retrieve <code>D</code>
        <strong>only when we really need</strong>. Performance! On the other side, some new problems are born:
    </p>
    <ul>
        <li>
            <strong>Our object cannot exist without a service locator</strong>: makes testability hard, since we will
            need to mock the service locator in order to test <code>HelloWorld</code>, and mocking a service locator
            is not so easy.
        </li>
        <li>
            <strong>Our object depends on the implementation of the service locator</strong>: portability of our code
            is reduced, since it will work only with a specific service locator implementing the <code>ServiceLocator</code>
            contract.
        </li>
        <li>
            <strong>Instantiation of dependencies moved to our code</strong>: instantiation of <code>D</code> should not
            be a problem solved by our code, but we introduced more code to be tested by handling lazy loading of it
            inside of <code>HelloWorld</code>
        </li>
        <li>
            <strong>Hardcoded service name in our code</strong>: we now have a hardcoded service name in our code. This
            makes our code very error prone if we don't write extensive integration tests. Also, it makes our code
            incompatible with anything sharing the same <code>ServiceLocator</code> instance and requiring an instance
            named <code>'D'</code>.
        </li>
    </ul>
    <p>
        Nice! We solved a performance problem to introduce at least 4 new ones! Not really nice, eh?
    </p>
    <p>
        If you are using service location, <strong>STOP NOW</strong> and please read the rest of this post.
    </p>

    <p>
        There must be a better solution... After all, what we want to avoid is instantiating <code>A, B, C, D</code> if
        we aren't using it. Doesn't sound so hard!
    </p>

    <h2>Doctrine Proxies to the rescue!</h2>
    <p>
        The idea is nothing new, and <a href="http://pooteeweet.org/" target="_blank">Lukas Smith</a> already
        <a href="https://github.com/symfony/symfony/issues/5012" target="_blank">discussed it on the Symfony2 issue tracker</a>.
    </p>
    <p>
        Since I was already playing around with code generation for doctrine, I decided to attempt to make this reality.
    </p>

    <hr/>

    <h2>What are Doctrine Proxies?</h2>
    <p>
        <a href="https://github.com/Ocramius/common/blob/DCOM-96/lib/Doctrine/Common/Proxy/Proxy.php" target="_blank">Doctrine Proxies</a>
        are a PHP implementation of the <a href="http://en.wikipedia.org/wiki/Proxy_pattern" target="_blank">proxy pattern</a>
        used to achieve <a href="http://www.martinfowler.com/eaaCatalog/lazyLoad.html" target="_blank">lazy loading</a>
        of objects from a persistent storage. Doctrine implements this pattern by having <strong>Virtual Proxies</strong>
        that behave like <strong>Ghost Objects</strong>.
    </p>
    <p>
        The concept behind proxies is quite simple: each time a method of the proxy is called, if the proxy is not
        initialized, initialize it (which corresponds to filling its fields with data coming from a DB). After that, run
        the code that was supposed to be executed with that method call.
    </p>
    <p>
        This is achieved by having Doctrine generate a class that inherits from the original object and faking all of
        its public API and adding the required code to trigger lazy loading:
    </p>
<pre class="prettyprint linenums lang-prepro">class UserProxy extends User
{
    protected $initialized = false;

    public function getUsername()
    {
        if ( ! $this-&gt;initialized) {
            initialize($this);
        }

        return parent::getUsername();
    }
}</pre>
    <p>
        The previous snippet isn't very flexible, but as you may know, Doctrine is a set of libraries focusing on persistence of data, and the
        <a href="https://github.com/doctrine/common/blob/8b403cde97eaede30bd79acab4f18895fd5bdf27/lib/Doctrine/Common/Persistence/Proxy.php"
           target="_blank">first version of proxies</a> was highly focused on supporting the purpose of loading an
        object from a database.
    </p>
    <p>
        The implementation has been enhanced with <a href="https://github.com/doctrine/common/pull/168" target="_blank">
        a patch I'm working on</a>, now allowing many different uses of the proxy pattern. This is mainly possible since
        because of <a href="http://php.net/manual/en/functions.anonymous.php" target="_blank">lambda functions in PHP</a>
        used as initialization logic for our proxy objects:
    </p>
<pre class="prettyprint linenums lang-prepro">class UserProxy extends User
{
    /** @var Closure */
    protected $initializer;

    public function __setInitializer(Closure $initializer)
    {
        $this-&gt;initializer = $initializer;
    }

    public function getUsername()
    {
        if ($this-&gt;initializer !== null) {
            call_user_func($this-&gt;initializer);
        }

        return parent::getUsername();
    }
}</pre>
    <p>
        Using a <a href="http://php.net/manual/en/class.closure.php" target="_blank">Closure</a> as an initializer
        now enables us to swap the initialization logic used for our proxy object. I won't get into details, but this
        is a requirement for our next step.
    </p>

    <h2>Why proxies?</h2>

    <p>
        Let's get back to the example with <code>A, B, C, D, HelloWorld</code>, but we'll introduce a proxy now:
    </p>
<pre class="prettyprint linenums lang-prepro">class A {}

class B {}

class C {}

class D
{
    public function __construct(A $a, B $b, C $c)
    {
        // ...
    }

    public function doSomething()
    {
        return 'Did something with ' . $this->a . ', ' . $this->b . ', ' . $this->c;
    }
}

class D_Proxy extends D
{
    private $serviceLocator;
    private $original;

    public function __construct(ServiceLocator $serviceLocator)
    {
        $this->serviceLocator = $serviceLocator;
    }

    private function initialize()
    {
        $this->initialized = true;
        $this->original    = $this->serviceLocator->get('D');
    }

    public function doSomething()
    {
        if ( ! $this->initialized) {
            $this->initialize();
        }

        return $this->original->doSomething();
    }
}

class HelloWorld
{
    public function __construct(D $d)
    {
        // ...
    }

    public function sayHello()
    {
        return 'Hello World';
    }

    public function doSomethingWithD()
    {
        if ( ! $this-&gt;d) {
            $this-&gt;d = $this-&gt;serviceLocator-&gt;get('D');
        }

        return $this-&gt;d-&gt;doSomething();
    }
}</pre>

    <p>
        Wait... What? Ok, let's slow this down a bit:
    </p>
    <ol>
        <li>
            You can now pass an instance of <code>D_Proxy</code> to <code>HelloWorld</code>. Since <code>D_Proxy</code>
            extends <code>D</code>, it respects the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle"
            target="_blank">Liskov substitution principle</a>.
        </li>
        <li>
            The proxy is uninitialized, and it is empty (we have replaced its constructor).
        </li>
        <li>
            When <code>doSomething</code> is called on the proxy, the real instance of <code>D</code> is retrieved
            from a service locator, and put into the <code>original</code> property.
        </li>
        <li>
            The method call is proxied to <code>$this->original->doSomething();</code>.
        </li>
        <li>
            Since the original object is fully populated with instances of <code>a</code>, <code>b</code> and
            <code>c</code>, code works as expected.
        </li>
    </ol>
    <p>
        We successfully avoided instantiating <code>A, B, C, D</code> when calling <code>sayHello</code>! Awesome!
    </p>

    <p>
        But wait: didn't I just say that service location is evil?
    </p>
    <p>
        Yes it is, but <code>D_Proxy</code> is generated code and:
    </p>
    <ul>
        <li>
            Its code generation is based on how the dependency injection container defined that <code>D</code> should
            be instantiated, thus the hardcoded <code>'D'</code> within the proxy code comes from the current DIC
            definitions. This allows it to have our DIC handling collisions between service names, and hardcoded
            magic strings disappear from our code base.
        </li>
        <li>
            It abstracts the problem of lazy initialization of a service for us, thus the generated code doesn't need
            to be tested as it is something tested by the implementor of the proxy generator (me).
        </li>
        <li>
            It has the same performance impact of introducing lazy initialization logic in our classes' methods (count
            the method calls, it's the same exact overhead).
        </li>
        <li>
            Turning on or off proxies does not change the functionality provided by our applications. They're just
            a performance tweak.
        </li>
        <li>
            Proxies actually allow cyclic dependencies. Since objects are lazily initialized, if <code>A</code> depends
            on <code>B</code>, and <code>B</code> depends on <code>A</code>, and one of those two is proxied, the lazy
            initialization mechanism will prevent us from triggering an infinite loop in our instantiation logic.
        </li>
    </ul>

    <hr/>

    <h2>General usage direction</h2>
    <p>
        Proxies also have some limitations though:
    </p>

    <ul>
        <li>
            <strong>Cannot benefit from the initializer pattern/setter injection</strong>: since any call to a proxy
            method that isn't its constructor would cause its initialization, setter injection cannot be used on a proxy,
            or it will basically render the underlying idea of performance tweak useless.
        </li>
        <li>
            <strong>Cannot proxy dynamic services</strong>: you can apply this proxy pattern only when assuming that
            calling <code>$serviceLocator->get('D');</code> will actually return an instance of <code>D</code>. If the
            return type varies depending on i.e. environment variables, this code will break.
        </li>
        <li>
            <strong>Must be synchronized</strong>: changing implementation of our proxies requires us to re-generate
            them so that they respect the contract of the class they proxy. Since generated code in PHP is hard to put
            into a cache (because opcode caches cannot act on serialized data) we need to save proxies to predictable
            location in our system in order to autoload them and avoid generating them over and over. That also means
            that we have to delete them when we change our code, so that we can let the generator rewrite them.
        </li>
    </ul>

    <hr/>

    <h2>Examples/benchmarks</h2>

    <p>
        If you want to read further on the proxy implementation I proposed for Zend Framework 2 you can check the
        <a href="https://github.com/zendframework/zf2/pull/2995" target="_blank">corresponding pull request</a>.
    </p>
    <p>
        If you are interested in how proxy generation works in Doctrine, you can check
        <a href="https://github.com/doctrine/common/pull/168" target="_blank">my current work</a> on doctrine common.
    </p>
    <p>
        I am also starting work to implement this idea for Symfony 2.
    </p>

    <hr/>

    <h2>Conclusions</h2>

    <p>
        I can conclude that the proxies are a good solution to solve the performance issues that are introduced by
        Dependency Injection Containers. They also allow us to completely get rid of service location and to focus
        on writing clean and robust classes that are easy to test.
    </p>
    <p>
        They surely add some magic to our code, and I've been already told by <a href="http://mwop.net/" target="_blank">
        Matthew Weier 'o Phinney</a> that some newcomers may be confused by the additional calls they will in stack
        traces when looking at exceptions.
    </p>
    <p>
        Anyway, proxies are not a requirement to get our application working. They are just steroids for our services,
        and I'd surely suggest you to use them.
    </p>
</div>