---
layout: post
title: Automated Test Coverage Checks with Travis, PHPUnit for Github Pull Requests
category: Coding
tags: zend zendframework dependency injection di dic soa mvc
year: 2012
month: 8
day: 6
published: true
summary: Developers are lazy, and their Pull Requests in Github often do not respect our code quality standards. Automate testing so that you can enforce a minimum PHPUnit Code Coverage in Travis!
---

<div class="row">
    <h2>Code quality</h2>
    <p>
        Github is fun, and it is a great place for showing off our coding skills and building great tools for our next
        great project!
        <br/>
        But what if we want to also ensure that our tool works perfectly?
        <br/>
        Obviously, <q>perfection</q> is not a term of the developer world. There is always a flaw waiting for us behind
        the corner, but we can do our best to try to avoid it by testing our code, and testing it well.
    </p>

    <hr/>

    <h2>Code coverage</h2>
    <p>
        <strong>Code coverage</strong> is one of the metrics we can get from
        <a href="https://github.com/sebastianbergmann/phpunit/" target="_blank">PHPUnit</a> tests, and it is a strong
        indicator of how hard we worked on testing our application. It is not an universal metric to define if our code
        works, and there is tons of examples of how your code can still be buggy even if every line of code was executed
        at least once. It should anyway not be ignored, and it is up to us to decide how hard we want to test each part
        of our application.
    </p>
    <p>
        That's why I came up with the idea of automating a simple coverage check on a
        <a href="https://github.com/RWOverdijk/AssetManager" target="_blank">library I was working on</a>.
    </p>

    <hr/>
    <h2>The script</h2>
    <p>
        What we basically want to do is to automate a very simple check that verifies that our test suite covered at
        least a given percentage of the
        <a href="http://pdepend.org/documentation/software-metrics/index.html" target="_blank">]
            <abbr title="Executable Lines Of Code">ELOC</abbr></a>.
        The script should exit with an <a href="http://en.wikipedia.org/wiki/Exit_status" target="_blank">exit code</a>
        different from <strong>1</strong> if the check wasn't successful, thus being recognized by our test runner as a
        failure.
    </p>
    <p>
        I will use <a href="http://travis-ci.org/" target="_blank">Travis-CI</a> for my examples, but what I am going to
        show can be easily integrated also in other
        <a href="http://en.wikipedia.org/wiki/Continuous_integration" target="_blank">Continuous Integration</a>
        environments.
    </p>

    <hr/>

    <h2>Getting started - PHPUnit</h2>
    <p>
        PHPUnit is able to generate log files in an XML format called <strong>clover</strong>. You will need to setup
        PHPUnit as following to generate a correct clover report:
    </p>
<pre class="prettyprint linenums lang-xml">&lt;?xml version="1.0"?&gt;
    &lt;!-- works fine with PHPUnit-3.6.10 --&gt;
&lt;phpunit&gt;
    &lt;!-- you can keep your own options in these elements --&gt;
    &lt;filter&gt;
        &lt;whitelist addUncoveredFilesFromWhitelist="true"&gt;
            &lt;!-- this is the path of the files included in your clover report --&gt;
            &lt;directory suffix=".php"&gt;./src&lt;/directory&gt;
        &lt;/whitelist&gt;
    &lt;/filter&gt;
    &lt;logging&gt;
        &lt;!-- and this is where your report will be written --&gt;
        &lt;log type="coverage-clover" target="./clover.xml"/&gt;
    &lt;/logging&gt;
lt;/phpunit&gt;</pre>

    <p>
        First, let's get a skeleton application to work. Please mind that we're going to work within the Application
        module provided by ZendSkeletonApplication, but you should apply these concepts only for your own modules!
    </p>

<pre class="prettyprint linenums lang-sh">~$ git clone git://github.com/zendframework/ZendSkeletonApplication.git
~$ cd ZendSkeletonApplication
~$ ./composer.phar install</pre>

    <p>
        <span class="label label-info">For the lazy:</span> If you just prefer to look at the code and run it
        without having to reproduce my example, you can just look at the already modified skeleton at
        <a href="http://github.com/Ocramius/ZendSkeletonApplication/tree/demo/zf2-controllers-from-zend-di/module">
            Ocramius/ZendSkeletonApplication - branch demo/zf2-controllers-from-zend-di
        </a> and see what I did in the
        <a href="http://github.com/Ocramius/ZendSkeletonApplication/compare/master...demo;zf2-controllers-from-zend-di" target="_blank">diff</a>.
    </p>

    <p>
        You should now be able to browse to <code>http://localhost/path-to-skeleton-application/</code> and see the
        ZendSkeletonApplication default intro page.
    </p>

    <hr/>

    <h2>The code</h2>
    <p>
        Here are our service, greeting container and controller: that's the core of our application. I will already
        start with IOC, since I don't think I need to explain why I like it (nor am I qualified to do so!), and you
        already have read this far.
    </p>

    <h4>Greetings repository:</h4>
    <p>
        A simple repository that fetches a random greeting message from an array.
    </p>
<pre class="prettyprint linenums lang-prepro">&lt;?php
// module/Application/src/Application/Repository/StaticGreetingRepository.php

namespace Application\Repository;

class StaticGreetingRepository
{
protected $availableGreetings = array('Hi', 'Hello', 'Hey', 'What\'s up');

/** @return string */
public function getRandomGreeting()
{
    return $this-&gt;availableGreetings[array_rand($this-&gt;availableGreetings)];
}
}</pre>

    <h4>Greetings service (consumes repository):</h4>
    <p>
        A service that assembles the entire message by picking a random greeting from a given repository and a
        provided name.
    </p>
<pre class="prettyprint linenums lang-prepro">&lt;?php
// module/Application/src/Application/Service/GreetingService.php

namespace Application\Service;

use Application\Repository\StaticGreetingRepository;

class GreetingService
{
protected $repository;

/** @var StaticGreetingRepository $repository */
public function __construct(StaticGreetingRepository $repository)
{
    $this-&gt;repository = $repository;
}

/**
 * this is an example method. It could perform operations such as discovering
 * the gender of the given name to customize the reply
 *
 * @var    string $name
 * @return string
 */
public function greet($name)
{
    return $this-&gt;repository-&gt;getRandomGreeting() . ' ' . $name . '!';
}
}</pre>

    <h4>Greetings controller (consumes service):</h4>
    <p>
        A controller we use to collect a <code>GET</code> request and return the message to the end user.
    </p>
<pre class="prettyprint linenums">&lt;?php
// module/Application/src/Application/Controller/GreetingController.php

namespace Application\Controller;

use Application\Service\GreetingService;
use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class GreetingController extends AbstractActionController
{
/**
 * @var GreetingService
 */
protected $greetingService;

/**
 * @var GreetingService $greetingService
 */
public function __construct(GreetingService $greetingService)
{
    $this-&gt;greetingService = $greetingService;
}

public function helloAction()
{
    $name = $this-&gt;getRequest()-&gt;getQuery('name', 'anonymous');

    return new ViewModel(array('greeting' =&gt; $this-&gt;greetingService-&gt;greet($name)));
}
}</pre>

    <h4>And then a view to see some output:</h4>
<pre class="prettyprint linenums lang-prepro">&lt;?php
// module/Application/view/application/greeting/hello.phtml
echo '&lt;h1&gt;' . $this-&gt;escapeHtml($this-&gt;greeting) . '&lt;/h1&gt;';
</pre>

    <hr/>

    <h2>Wiring it together</h2>
    <p>
        To allow <code>Zend\Di</code> to work correctly with our application, we now need to allow our application
        to access the controller somehow. To do so, we have to define <code>config.di.allowed_controllers</code> and
        a route to allow access to our controller (and a couple of fixes required to inject inherited dependencies).
    </p>

<pre class="prettyprint linenums lang-prepro">&lt;?php

return array(
'di' =&gt; array(
    'allowed_controllers' =&gt; array(
        // this config is required, otherwise the MVC won't even attempt to ask Di for the controller!
        'Application\Controller\GreetingController',
    ),

    'instance' =&gt; array(
        'preference' =&gt; array(
            // these allow injecting correct EventManager and ServiceManager
            // (taken from the main ServiceManager) into the controller,
            // because Di doesn't know how to retrieve abstract types. These
            // dependencies are inherited from Zend\Mvc\Controller\AbstractController
            'Zend\EventManager\EventManagerInterface' =&gt; 'EventManager',
            'Zend\ServiceManager\ServiceLocatorInterface' =&gt; 'ServiceManager',
        ),
    ),
),

'router' =&gt; array(
    'routes' =&gt; array(
        'hello' =&gt; array(
            'type' =&gt; 'Zend\Mvc\Router\Http\Literal',
            'options' =&gt; array(
                'route'    =&gt; '/hello',
                'defaults' =&gt; array(
                    'controller' =&gt; 'Application\Controller\GreetingController',
                    'action'     =&gt; 'hello',
                ),
            ),
        ),
    ),
),

// remaining config
);</pre>

    <hr/>

    <h2>Running it!</h2>
    <p><strong>Seriously?</strong> Was that all? The answer is yes!</p>
    <p>This will give you a basic example that renders a web page like the following:</p>

    <p>
        <img
            style="box-shadow: 0 0 3px 5px #000"
            src="/img/posts/2012-08-6-zend-framework-2-controllers-and-dependency-injection-with-zend-di/zend-di-controller-sample-preview.png"
            alt="Preview of the output of the Zend\Di based Mvc SOA example"
        />
    </p>

    <hr/>

    <h2>Considerations</h2>
    <p>
        Ok, what did just happen? <code>Zend\Di</code> recursively discovered all hard dependencies and built a
        fully operational controller for us! And that with very clean and simple code.
    </p>
    <p>
        Some may argue that this is "dark magic". It is not, it is just another way of wiring things together,
        and I am not suggesting it for your production environment nor as a definitive solution to solve all your
        dependency injection problems: just for development.
    </p>

    <hr/>

    <h2>Performance issues</h2>
    <p><span class="label label-important">Careful!</span> Performance impact of using <code>Zend\Di</code> over a
        ServiceManager factory is around 15%, and that overhead increases with the number and recursion of the
        dependencies.
        Enabling complex Di based modules such as <a href="https://github.com/Ocramius/ZfPhpcrOdm" target="_blank">
        ocramius/zf-phpcr-odm</a> may affect performance by an order of 200% or more!
    </p>
    <p>
        But that is perfectly fine in a development environment, since we want to get working as fast as possible
        and keeping our code clean and simple. This is simply not possible in a context where dependencies continue
        to change because of architectural changes in your application. You must be free to do your decisions before
        freezing everything into a Service Factory!
    </p>
    <p>
        If you want to remove the performance overhead and still keep the benefits of using Zend\Di, you can try my
        <a href="https://github.com/Ocramius/OcraDiCompiler" target="_blank">ocramius/ocra-di-compiler</a>, which
        simply does the work you should do when you want to compile your Di container into a series of service
        factories/PHP closures.
    </p>
    <p>
        Otherwise, simply do following in your configuration once you are sure your dependencies won't change much:
    </p>

<pre class="prettyprint linenums lang-prepro">&lt;?php

return array(
'controllers' =&gt; array(
    'factories' =&gt; array(
        'Application\Controller\GreetingController' =&gt; function($sm) {
            return new \Application\Controller\GreetingController(
                new \Application\Service\GreetingService(
                   new \Application\Repository\StaticGreetingRepository()
                ),
            ),
        },
    ),
),

// remaining config
);</pre>

    <p>
        This basically removes all the overhead, but also removes the flexibility of <code>Zend\Di</code>, since
        you won't be able to swap the implementation of either the <code>GreetingService</code> or the
        <code>StaticGreetingRepository</code> used to dispatch your request. I personally see this as one of the
        last steps before shipping your code for production, since OcraDiCompiler can handle these operations for
        you.
    </p>

    <p>
       <span class="label label-info">Note:</span>  Please also note that in this example, all dependency injection
         are based on type hints of concret  implementations. I cleaned up my code and invite you to check
        <a href="http://github.com/Ocramius/ZendSkeletonApplication/tree/demo/zf2-controllers-from-zend-di-cleanup/module" target="_blank">
            Ocramius/ZendSkeletonApplication - demo/zf2-controllers-from-zend-di-cleanup
        </a> and see what I did in the
        <a href="http://github.com/Ocramius/ZendSkeletonApplication/compare/demo;zf2-controllers-from-zend-di...demo;zf2-controllers-from-zend-di-cleanup" target="_blank">diff</a>.
        In this case I simply exchanged the type hints with abstract types (which allow more flexibility) and taught
        <code>Zend\Di</code> how to handle injections for them.
    </p>

    <p>
        To check how I improved performance using <code>ocramius/ocra-di-compiler</code>, please refer to branch
        <a href="http://github.com/Ocramius/ZendSkeletonApplication/tree/demo/zf2-controllers-from-zend-di-with-compiled-di/module" target="_blank">
            Ocramius/ZendSkeletonApplication - demo/zf2-controllers-from-zend-di-with-compiled-di
        </a> and to the related <a href="http://github.com/Ocramius/ZendSkeletonApplication/compare/demo;zf2-controllers-from-zend-di-cleanup...demo;zf2-controllers-from-zend-di-with-compiled-di" target="_blank">diff</a>.
    </p>

    <hr/>

    <h2>Conclusions</h2>
    <p>
        As I've stated from the beginning, this is a development process, not something you want to have happening
        at runtime at every request. <code>Zend\Di</code> is a very powerful tool, especially when it comes to
        testing, exchenging deeply nested dependencies and keeping IOC as clean as possible. Use it wisely and it
        may become your best ally while handling your usual impossible customer, but maybe this time without
        screwing up as much code as usual ;-)
    </p>
</div>